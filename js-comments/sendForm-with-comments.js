"use strict";

const form = document.querySelector('.form-test-drive')


form.addEventListener('submit', (event) => {
  //1.1 Чтобы при клике на кнопку с атрибутом "submit" и методом "GET" не происходила авто-перезагрузка страницы, нужно отключить стандартное поведение методом event.preventDefault().
  event.preventDefault()

  //1.6 Также нам нужен объект для хранения в нём всех собранных данных, который мы потом передадим по нужному нам адресу или email.
  let data = {}

  //1.2 Собираем данные формы: Создадим каждый очередной элемент при переборе. Обратимся к форме и её свойству "elements", то есть каждому элементу формы.
  //1.5 Проведём "деструктуризацию", таким образом мы ещё при создании переменной извлекаем из неё свойства "name" и "value".
  for (let {name, value} of form.elements) {
    //1.3 Нам требуются только данные из формы, поэтому кнопку нужно исключить из собранных элементов формы. Т.к. у каждого input есть атрибут "name", а у кнопки его нет, укажем следующее условие "если атрибут 'name' существует, тогда выполняй".
    //1.4 Введённые в input данные хранит свойство "value".
    //1.7 Внутри условия будем заполнять созданный выше пустой объект. Ключём у нас будет name, т.е. название типа информации, а значением - value, сама информация (имя, email, номер телефона и т.д.)
    if (name) {
      data[name] = value
    }
  }
  //2.1 Метод fetch() делает запрос на endpoint. В метод fetch() кроме самого URL-адреса мы можем передавать также через запятую объект с настройками в фигурных скобках, где мы указываем параметры нашего запросы. К примеру method. Также нам необходимо отправлять тело запроса - объект 'data'. Данный объект помещается в свойство body.
  //2.1.2 Чтобы отправлять данные в нужном виде, нам нужно их перекодировать с помощью метода JSON.stringify(). Таким образом данные будут переведены в строчный тип данных. Именно в этом виде сервер и ожидает эти данные. (см. Networl -> Payload в DevTools)
  //2.2 Далее после точки применяем метод then. Этот метод отработает тогда, когда данные полностью будут получены. Он получит некий response, т.е. ответ от сервера. Но этот ответ изначально находится в несколько нечитабельном виде и его придётся перекодировать в читабельный методом json(). Но сперва, нужно убедиться, что мы получаем status: 200 (успешный приём данных с сервера). Пишем проверку и условие для неё.
  //2.3 Следующий then() уже получит ответ в читабельном виде.
  //2.4 Т.к. нам нужен не только GET-запрос получения данных, но и POST-запрос отправки, то обработаем также и 201 статус (успешной отсылки данных на сервер).
  fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    body: JSON.stringify(data)
  })
    .then(response => {
      if (response.status === 200 || response.status === 201) {
        return response.json()
      } else {
        //2.5 Также нужно обработать все статусы ответа-исключения, всё, что не 200 и не 201 должно выбросить нам ошибку в консоль.
        throw new Error(response.status)
      }
    })
    .then(data => {
      //2.6.1 Оповещаем пользователя о сохранении данных.
      alert('Данные успешно сохранены!')
      //2.6.2 Очищаем форму
      form.reset()
      //2.7 Для того, чтобы вывести ошибку, мы должны её сперва перехватить и для этого используем метод catch(), который принимает в параметр саму ошибку. Выводим её во всплывающее окошко. Однако сам код из-за неё не падает, благодаря методу catch().
    })
    .catch(error => {
      alert('Произошла ошибка, статус ' + error.message)
    })
})

// Endpoint - так называют URL-адрес, по которому сервер принимает данные и сохраняет их в базе данных.
// Т.к. такого endpoint у нас здесь нет, то для тестов удобно использовать сервис jsonplaceholder.typicode.com